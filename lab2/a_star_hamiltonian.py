# -*- coding: utf-8 -*-
"""a_star_hamiltonian.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HMYQysMVuQ9qGSNN1H-M-LB1neLwSLf0
"""

import heapq
import math


def edge_cost(graph, u, v):
    for nei, w in graph.get(u, []):
        if nei == v:
            return w
    return math.inf


def prim_mst(graph, nodes):
    if not nodes:
        return 0

    nodes = list(nodes)
    in_tree = {nodes[0]}
    total_cost = 0

    while len(in_tree) < len(nodes):
        best_edge = math.inf
        next_node = None
        for u in in_tree:
            for v, w in graph.get(u, []):
                if v in nodes and v not in in_tree and w < best_edge:
                    best_edge, next_node = w, v
        if next_node is None:
            return math.inf
        total_cost += best_edge
        in_tree.add(next_node)

    return total_cost


def heuristic(curr, unvisited, graph, start):
    if not unvisited:
        return edge_cost(graph, curr, start)

    from_curr = min(edge_cost(graph, curr, v) for v in unvisited)

    mst_cost = prim_mst(graph, unvisited)

    to_start = min(edge_cost(graph, v, start) for v in unvisited)

    return from_curr + mst_cost + to_start


def tsp_astar(graph, start=0):
    n = len(graph)
    all_visited_mask = (1 << n) - 1

    initial_unvisited = {i for i in range(n) if i != start}
    pq = [(heuristic(start, initial_unvisited, graph, start), 0, start, 1 << start, [start])]
    best_state = {}

    while pq:
        f, g, node, visited_mask, path = heapq.heappop(pq)

        if visited_mask == all_visited_mask:
            return g + edge_cost(graph, node, start), path + [start]

        if (node, visited_mask) in best_state and best_state[(node, visited_mask)] <= g:
            continue
        best_state[(node, visited_mask)] = g

        for nxt, w in graph.get(node, []):
            if visited_mask & (1 << nxt):
                continue
            new_mask = visited_mask | (1 << nxt)
            new_g = g + w
            unvisited = {i for i in range(n) if not (new_mask & (1 << i))}
            h = heuristic(nxt, unvisited, graph, start)
            if h == math.inf:
                continue
            heapq.heappush(pq, (new_g + h, new_g, nxt, new_mask, path + [nxt]))

    return math.inf, []


if __name__ == "__main__":
    graph = {
        0: [(1, 14), (2, 9), (3, 7)],
        1: [(0, 14), (2, 10), (3, 8), (5, 6)],
        2: [(0, 9), (1, 10), (3, 11)],
        3: [(0, 7), (1, 8), (2, 11), (4, 9)],
        4: [(3, 9), (5, 8)],
        5: [(1, 6), (4, 8)]
    }

    cost, cycle = tsp_astar(graph, start=0)
    if cost == math.inf:
        print("No Hamiltonian cycle exists")
    else:
        print("Optimal Hamiltonian Cycle:", cycle)
        print("Minimum Cost:", cost)