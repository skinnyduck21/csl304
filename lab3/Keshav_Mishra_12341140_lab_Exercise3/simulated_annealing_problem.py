# -*- coding: utf-8 -*-
"""simulated_annealing_problem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xclF8BIRAnWmgVbtbQFOQAI50xTwTjMW
"""

import random
import math

def count_conflicts(board):
    n = len(board)
    attacks = 0
    for i in range(n):
        for j in range(i+1, n):
            if board[i] == board[j] or abs(board[i] - board[j]) == abs(i - j):
                attacks += 1
    return attacks

def generate_neighbor(board):
    n = len(board)
    new_board = board[:]
    col = random.randrange(n)
    new_row = random.randint(1, n)
    new_board[col] = new_row
    return new_board

def simulated_annealing(n=8, start_temp=500.0, cooling=0.98, max_steps=50000):
    state = [random.randint(1, n) for _ in range(n)]
    curr_conf = count_conflicts(state)

    best_state, best_conf = state[:], curr_conf
    temperature = start_temp

    for step in range(max_steps):
        if curr_conf == 0:
            return state, True

        neighbor = generate_neighbor(state)
        neighbor_conf = count_conflicts(neighbor)
        delta = neighbor_conf - curr_conf

        if delta < 0 or random.random() < math.exp(-delta / temperature):
            state, curr_conf = neighbor, neighbor_conf
            if curr_conf < best_conf:
                best_state, best_conf = state[:], curr_conf

        temperature *= cooling
        if temperature < 1e-6:
            break

    return best_state, (best_conf == 0)

solution, is_valid = simulated_annealing()

print("Best board found:", solution)
print("Conflicts:", count_conflicts(solution))

if is_valid:
    print("Valid solution found")
else:
    print("No perfect solution, but near optimal returned")